#!/usr/bin/env python
"""This script re-plots results of pythran-replay.
"""

import os
import sys
import argparse
import re
import matplotlib.pyplot as plt
try:
    from collections import OrderedDict
except ImportError:
    from ordereddict import OrderedDict
import linecache
import logging

# logger setup
logging.basicConfig(level=logging.DEBUG,
                    format='%(asctime)s %(levelname)s:  %(message)s',
                    datefmt='%m/%d/%Y %H:%M:%S',
                    filename='.plot-result.err',
                    filemode='w')

console = logging.StreamHandler()
console.setLevel(logging.DEBUG)
formatter = logging.Formatter(
    '%(levelname)s:  %(message)s', '%m/%d/%Y %H:%M:%S')
console.setFormatter(formatter)
logging.getLogger('').addHandler(console)

log = logging.getLogger(__name__)


def get_basic_info(filepath):
    url = linecache.getline(filepath, 6).split(':')[1].strip()
    branch = linecache.getline(filepath, 7).split(':')[1].strip()
    return OrderedDict({
        'url': url,
        'branch': branch})


def patch_results(results, basic_info):
    """Fill failed commits with NaN"""
    import git
    import numpy as np
    repo = git.Repo(basic_info['url'])
    commits = repo.iter_commits(basic_info['branch'])
    p_results = OrderedDict()

    for commit in commits:
        if commit.__str__() in results.keys():
            p_results[commit.__str__()] = results[commit.__str__()]
            continue
        else:
            p_results[commit.__str__()] = OrderedDict({
                "compile_time": np.nan,
                "best_time": np.nan,
                "worst_time": np.nan,
                "median_time": np.nan,
                "mean_time": np.nan})

    return p_results


def get_results(filepath):
    with open(filepath, "r") as f:
        results = OrderedDict()
        commit_pattern = "\[commit [0-9]+\][.]*"
        commit_id_pattern = "[0-9a-zA-Z]{40,40}"
        time_pattern = "[0-9]+\.[0-9]+"

        commits = []
        # read commits
        for line in f:
            if re.match(commit_pattern, line):
                tmp_result = OrderedDict()
                commit = re.findall(commit_id_pattern, line)[0]
                commits.append(commit)
                results[commit] = tmp_result

        def read_time(pattern, key):
            f.seek(0)
            cnt = 0
            for line in f:
                if re.match(pattern, line):
                    t = re.findall(time_pattern, line)[0]
                    results[commits[cnt]][key] = float(t)
                    cnt += 1

        read_time(".*Compile time.*", 'compile_time')
        read_time(".*Best time.*", 'best_time')
        read_time(".*Worst time.*", 'worst_time')
        read_time(".*Mean time.*", 'mean_time')
        read_time(".*Median time.*", 'median_time')

    return results


def plot_results(results, show=True, title=None):
    """
    """
    compile_times = []
    best_times = []
    mean_times = []
    worst_times = []
    median_times = []
    xcnts = []
    cnt = 0

    for commit, result in results.items():
        cnt += 1
        xcnts.append(cnt)
        best_times.append(result['best_time'])
        mean_times.append(result['mean_time'])
        worst_times.append(result['worst_time'])
        median_times.append(result['median_time'])
        compile_times.append(result['compile_time'])

    plt.suptitle(title) if title else plt.suptitle("Commits History")
    #compile_ax configure
    plt.subplot(211)
    plt.plot(xcnts, compile_times, '--r*')
    plt.ylabel("Compile time")
    plt.grid(True)
    plt.xlim([0, xcnts[-1] + 1])

    #execute_ax configure
    plt.subplot(212)
    plt.plot(xcnts, best_times, '--g*', label='$BestTime$')
    plt.ylabel("Execute time")
    plt.xlabel("Commit")
    plt.grid(True)
    plt.xlim([0, xcnts[-1] + 1])

    if show:
        plt.show()


def parse_args():
    parser = argparse.ArgumentParser(description="Plot results")
    parser.add_argument("logfile")
    parser.add_argument(
        "--all", action="store_true", help="show all commits")
    return parser.parse_args()


def main():
    options = parse_args()

    if not os.path.exists(options.logfile):
        log.error("%s doesn't exist!" % logfile)
        sys.exit()

    results = get_results(options.logfile)

    if options.all:
        basic_info = get_basic_info(options.logfile)
        results = patch_results(results, basic_info)

    plot_results(results, title=options.logfile[:-4])


if __name__ == "__main__":
    main()
