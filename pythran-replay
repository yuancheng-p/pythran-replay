#!/usr/bin/env python
"""
./pythran-replay ./benchmark/dprod/dprod.py
    -s 'from dprod import dprod;l0=[1]*100000;l1=[2]*100000'
    'dprod(l0,l1)' --url ../pythran -b master -n 100
    --count_rng cc9294c07bfcc46540223700a1bb951219dccabc:20:2
"""
import argparse
import imp
import os
from time import time, strftime, localtime
import timeit
import git
try:
    from collections import OrderedDict
except:
    from ordereddict import OrderedDict
import logging
import matplotlib.pyplot as plt
import commands
import sys
import numpy as np
import ConfigParser
import re

# log settings
log = logging.getLogger(__name__)
log.setLevel(logging.DEBUG)
ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)
formatter = logging.Formatter(
    '%(levelname)s:  %(message)s')
ch.setFormatter(formatter)
log.addHandler(ch)

# read config
config = ConfigParser.RawConfigParser()
if not os.path.exists('.replay-config'):
    log.error('.replay-config not found!')
    exit()
config.read('.replay-config')


def verify_commit(branch, commit):
    commits = REPO.iter_commits(branch)

    for current in commits:
        return current.__str__() == commit

    log.error("commit \"%s\" is not in the branch \"%s\"" % (commit, branch))
    sys.exit()


def iter_count_commits(branch, begin, count=1, step=1):
    """ Iterate commits with a begin commit

    count is the number of commits selected
    step is the distance between two commits to compile
    """
    verify_commit(branch, begin)
    commits = REPO.iter_commits(branch)
    cnt = 0
    already_begin = False

    for commit in commits:
        if cnt == count:
            break
        if commit.__str__() == begin or already_begin:
            if not already_begin:
                already_begin = True
            if cnt % step == 0:
                yield commit
            cnt += 1


def iter_commits(branch, begin, end, step=1):
    """ Iterate commits with a begin commit and an end commit

    step is the distance between two commits
    """
    verify_commit(branch, begin)
    verify_commit(branch, end)
    commits = REPO.iter_commits(branch)
    cnt = 0
    already_begin = False

    for commit in commits:
        if commit.__str__() == end:
            break
        if commit.__str__() == begin or already_begin:
            if not already_begin:
                already_begin = True
            if cnt % step == 0:
                yield commit
            cnt += 1


def compile_bench_for_commit(bench, commit, url=".", quiet=False):
    """Comile a benchmark for a pythran commit

    The benchmark is a **pythran file path**
    return the compile time or -1 if compile failed
    """
    def compile_once(script):
        tic = time()
        fail = commands.getstatusoutput(script)
        toc = time()
        if fail[0] != 0:
            raise Exception(fail[1])
        elif fail[1] != '' and not quiet:
            log.warn("Pythran warning\n%s" % fail[1])
        return toc - tic

    REPO.git.checkout(commit)
    cppflags = config.get('user', 'cppflags')
    script = "python %s/scripts/pythran %s %s" % (url, cppflags, bench)
    try:
        compile_time = compile_once(script)
    except Exception as e:
        error_type = type(e).__name__
        error_msg = str(e)
        log.error("**Failed to compile %s", bench)
        if not quiet:
            log.error("\n%s" % (error_msg))
        return -1
    return compile_time


def clean_workspace():
    os.system("rm -f *.so parsetab.py a.out")


def build_reports(options, results, total_time, filename="report"):
    filepath = "%s.log" % (filename)
    fnum = 0
    while os.path.exists(filepath):
        fnum += 1
        filepath = "%s_%d.log" % (filename, fnum)
    log.info("Building reports \"%s\"" % filepath)

    f = file(filepath, "w")

    # get begin commit and step
    if options.count_range:
        selects = options.count_range.split(":")
        step = selects[2]
        begin_commit = selects[0]
    else:
        selects = options.range.split(":")
        begin_commit = selects[0]
        step = selects[2] if len(selects) == 3 else 1

    # write basic info:
    f.write(
        """##
#
# Date: %s
#
# [REPO INFORMATION]
#     url: %s
#     branch: %s
#
# [BENCHMARK]
#     benchmark: %s
#     setup: %s
#     statement: %s
#
# [COMMITS SELECTED]
#     start commit: %s
#     step: %s
#
# [TIMEIT]
#     number: %d
#     repeat: %d
#
# [RESULTS]
#     total : %d
#     passed: %d
#     finished in: %.2f seconds
##
""" % (
        strftime("%X, %x, %Z", localtime()), options.url, options.branch,
        options.bench, options.setup, ";".join(options.statement),
        begin_commit, step, options.number, options.repeat,
        sum(1 for commit in get_commits(options)),
        len(results), total_time))

    # write results
    count = 1
    for commit, result in results.items():
        f.write(
            """

[commit %d] %s
    Compile time: %s
    Best time: %s
    Worst time: %s
    Mean time: %s
    Median time: %s
    Author: %s
    Authored date: %s
    message: %s

""" % (
            count, commit.hexsha, result['compile_time'],
            result['best_time'], result['worst_time'],
            result['mean_time'], result['median_time'],
            commit.author.name.encode("utf8"),
            strftime("%X, %x, %Z", localtime(commit.authored_date)),
            commit.message.encode("utf8")))
        count += 1

    f.close()
    return filepath


def plot_results(results, title=None, scale=None, ):
    """plot and show figure"""
    compile_times = []
    best_times = []
    mean_times = []
    worst_times = []
    median_times = []
    xcnts = []
    cnt = 0

    for commit, result in results.items():
        cnt += 1
        xcnts.append(cnt)
        best_times.append(result['best_time'])
        mean_times.append(result['mean_time'])
        worst_times.append(result['worst_time'])
        median_times.append(result['median_time'])
        compile_times.append(result['compile_time'])

    plt.suptitle(title) if title else plt.suptitle("Commits History")
    #compile_ax configure
    plt.subplot(211)
    plt.plot(xcnts, compile_times, '--r*')
    plt.ylabel("Compile time")
    plt.grid(True)
    up = max(compile_times) + 2
    down = min(compile_times) - 2
    plt.ylim([down, up])
    plt.xlim([0, xcnts[-1] + 1])
    #execute_ax configure
    plt.subplot(212)
    plt.plot(xcnts, best_times, '--g*', label='$BestTime$')
    plt.plot(xcnts, worst_times, '--r*', label='$WorstTime$')
    plt.plot(xcnts, mean_times, '--yo', label='$MeanTime$')
    plt.plot(xcnts, median_times, '--bo', label='$MedianTime$')
    plt.ylabel("Execute time")
    plt.xlabel("Commit")
    plt.legend()
    plt.grid(True)
    plt.xlim([0, xcnts[-1] + 1])
    plt.show()


def parse_args(args):
    parser = argparse.ArgumentParser(description="Pythran Commits Replay Tool")

    # positional args
    parser.add_argument("bench", type=str, help="Pythran declared python file")
    parser.add_argument("statement", type=str, nargs="+", help="")

    # optional args
    parser.add_argument(
        "-s", "--setup", default="pass",
        help="statement to be executed once initially, by defaut pass")
    parser.add_argument(
        "-n", "--number", type=int, default=100,
        help="how many times to execute 'statement', by default 100")
    parser.add_argument(
        "-r", "--repeat", type=int, default=3,
        help="how many times repeat the experiment, by default 3")
    parser.add_argument(
        "--url", type=str, default=".", help="pythran repository path")
    parser.add_argument(
        "-b", "--branch", default='master',
        help="git branch, by default master")
    parser.add_argument(
        "--show", action="store_true",
        help="show plot results after execution")
    parser.add_argument(
        "-q", "--quiet", action="store_true",
        help="do not show pythran compile error or warning message")

    # commits selection
    group = parser.add_mutually_exclusive_group()
    group.add_argument(
        "--range", default=None, help="r0[:rn[:step]]")
    group.add_argument(
        "--count_range", default=None,
        help="starting commit_id and number of commits r_0:n:step.")

    return parser.parse_args()


def get_commits(options):
    if options.range:
        regex = "^[0-9a-zA-Z]{40,40}(:[0-9a-zA-Z]{40,40})?(:[0-9]{1,3})?$"
        if not re.match(regex, options.range):
            log.error("--range is not valid!")
            sys.exit()
        selects = options.range.split(":")
        if len(selects) == 1:
            commits = iter_count_commits(options.branch, selects[0], 1, 1)
        elif len(selects) == 2:
            commits = iter_commits(options.branch, selects[0], selects[1], 1)
        elif len(selects) == 3:
            commits = iter_commits(
                options.branch,
                selects[0], selects[1], selects[2])
    elif options.count_range:
        regex = "^[0-9a-zA-Z]{40,40}(:[0-9]{1,4})?(:[0-9]{1,3})?$"
        if not re.match(regex, options.count_range):
            log.error("--count_range is not valid!")
            sys.exit()
        cnt_rng = options.count_range.split(":")
        commits = iter_count_commits(
            options.branch, cnt_rng[0],
            int(cnt_rng[1]), int(cnt_rng[2]))
    else:
        commits = iter_count_commits(
            options.branch, REPO.heads[options.branch].commit.__str__(),
            9999, 1)

    return commits


if __name__ == "__main__":

    options = parse_args(sys.argv[1:])
    global REPO

    REPO = git.Repo(options.url)

    if not os.path.exists(options.bench):
        log.error("file \"%s\" doesn't exist" % options.bench)
        sys.exit()

    num_commits = sum(1 for commit in get_commits(options))
    commits = get_commits(options)
    results = OrderedDict()
    commit_count = 1
    clean_workspace()

    begin_run = time()
    for commit in commits:
        # compile
        log.info(
            "[commit %d / %d] %s" %
            (commit_count, num_commits, commit.__str__()))
        commit_count += 1
        compile_time = compile_bench_for_commit(
            options.bench, commit, options.url, quiet=options.quiet)

        if compile_time == -1:
            continue  # skip if fail to compile

        log.info("**compile time: %.3f seconds" % compile_time)

        try:
            t = timeit.Timer(
                stmt="\n".join(options.statement), setup=options.setup)
            records = t.repeat(repeat=options.repeat, number=options.number)
            best_time = min(records)
            worst_time = max(records)
            median_time = np.median(records)
            mean_time = np.mean(records)
            log.info("**%d loops, best of %d: %.6f seconds" %
                    (options.number, options.repeat, best_time))
            results[commit] = OrderedDict({
                "compile_time": compile_time, "best_time": best_time,
                "worst_time": worst_time, "median_time": median_time,
                "mean_time": mean_time})
        except Exception:
            log.warn(
                "\nOccurred an error in the timeit module which " +
                "might continue happening in the following commits! " +
                "<Ctrl + C> to stop running")
            t.print_exc()
        clean_workspace()
    end_run = time()

    total_time = end_run - begin_run
    basename = os.path.basename(options.bench)
    filename = "%s_%s" % (basename[:-3], options.branch)
    filename = re.sub(r"/", "_", filename)
    if results != {}:
        filepath = build_reports(options, results, total_time, filename)
        if options.show:
            plot_results(results, title=filepath[:-4])
    log.info("finished in %3f seconds" % total_time)
