#!/usr/bin/env python
"""
./pythran-replay ./benchmark/dprod/dprod.py
    -s 'from dprod import dprod;l0=[1]*100000;l1=[2]*100000'
    'dprod(l0,l1)' -b master -n 100
    --count_rng cc9294c07bfcc46540223700a1bb951219dccabc:20:2
"""
import argparse
import imp
import os
from time import time, strftime, gmtime
import timeit
import git
try:
    from collections import OrderedDict
except:
    from ordereddict import OrderedDict
import logging
import matplotlib.pyplot as plt

# log settings
log = logging.getLogger(__name__)
log.setLevel(logging.DEBUG)
ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)
formatter = logging.Formatter(
    '%(asctime)s\t%(levelname)s:  %(message)s', '%m/%d/%Y %H:%M:%S')
ch.setFormatter(formatter)
log.addHandler(ch)


def iter_count_commits(branch, begin, count, step=1):
    """ Iterate commits with a begin commit

    count is the number of commits retured
    step is the distance between two commits
    """
    commits = REPO.iter_commits(branch)
    cnt = 0
    already_begin = False

    for commit in commits:
        if cnt == count:
            break

        if commit.__str__() == begin or already_begin:
            if not already_begin:
                already_begin = True
            if cnt % step == 0:
                yield commit
            cnt += 1


def iter_commits(branch, begin, end, step=1):
    """ Iterate commits with a begin commit and an end commit

    step is the distance between two commits
    """
    commits = REPO.iter_commits(branch)
    cnt = 0
    already_begin = False

    for commit in commits:
        if commit.__str__() == end:
            break

        if commit.__str__() == begin or already_begin:
            if not already_begin:
                already_begin = True
            if cnt % step == 0:
                yield commit
            cnt += 1


def compile_bench_for_commit(bench, commit, repo_path="."):
    """comile a bench for a pythran commit

    the bench is the **pythran file path**
    return: compile time
    """
    def compile_once(script):
        tic = time()
        os.system(script)
        toc = time()
        return toc - tic

    REPO.git.checkout(commit)
    log.info("current commit: " + REPO.head.commit.__str__())
    script = "python %s/scripts/pythran %s" % (repo_path, bench)
    return compile_once(script)


def parse_args(args):
    """
    classic senario:
    ./pythran-reply <pythran file> [-s SETUP] [statement]
    """
    parser = argparse.ArgumentParser(
        description="Pythran Commits Replay Tool")
    # positional
    parser.add_argument("bench", type=str, help="Pythran declared python file")
    parser.add_argument("statement", type=str, nargs="+", help="")

    # optional
    # TODO setup can be a python file ?
    parser.add_argument(
        "-s", "--setup",
        help="statement to be executed once initially")
    parser.add_argument(
        "-n", type=int, default=10000,
        help="how many times to execute 'statement'")
    parser.add_argument(
        "-r", "--repeat", type=int, default=3)
    parser.add_argument(
        "-b", "--branch", default='master',
        help="git branch, by default master")
    parser.add_argument(
        "--show", action="store_true",
        help="show plot results after execution")
    parser.add_argument(
        "--repo_path", type=str, default=".",
        help="pythran repository path")

    # commits selection
    group = parser.add_mutually_exclusive_group()
    group.add_argument(
        "--rng", default=None,
        help="starting and ending commit_id r_0:r_n:step.")
    group.add_argument(
        "--count_rng",
        help="starting commit_id and number of commits r_0:n:step.")
    group.add_argument(
        "-c", "--commit", help="run for a specific commit")

    return parser.parse_args()


def clean_workspace():
    os.system("rm -f *.so")


def plot_results(results, figname, show=True):
    """
    results is an OrderedDict
    x: commit_date
    y: best_time
    """

    commits_time = []
    execute_times = []
    xcnts = []
    cnt = 0

    for commit, result in results.items():
        cnt += 1
        xcnts.append(cnt)
        timestr = strftime(
            "%X, %x", gmtime(commit.committed_date))
        commits_time.append(timestr)
        execute_times.append(result['best_time'])

    commits_time.reverse()
    execute_times.reverse()

    plt.xlabel("commit_date")
    plt.xticks(xcnts, commits_time, rotation=15)
    plt.ylabel("execute_time")
    plt.title("commits performance history")

    # TODO users can choose the scale of Y axis
    plt.plot(xcnts, execute_times, '--r*', label="$master$")

    filepath = "%s.png" % (figname)
    plt.savefig(filepath, dpi=100)

    if show:
        plt.show()


if __name__ == "__main__":
    import sys
    import re

    options = parse_args(sys.argv[1:])
    global REPO

    """ in the options:
    *bench:      pythran file path
    *statement:  statement to time
     setup:      statement to be executed once initially
     n:          how many times to execute 'statement'
     repeat:     number of experiments
     rng:        Starting and ending commit_id r0:rN:step.
     count_rng:  Starting commit_id and number of commits r0:N:step.
     commit:     Run a benchmark for a specific commit
     show:       show plot figure after execution
     repo_path:  pythran repository path
    """

    REPO = git.Repo(options.repo_path)

    if options.count_rng:
        cnt_range = options.count_rng.split(":")
        # TODO commit id perhaps can not be found in this branch
        commits = iter_count_commits(
            options.branch,
            cnt_range[0], int(cnt_range[1]), int(cnt_range[2]))
    elif options.rng:
        rng = options.rng.split(":")
        # TODO commit id perhaps can not be found in this branch
        commits = iter_commits(
            options.branch,
            rng[0], rng[1], int(rng[2]))
    elif options.commit:
        # TODO commit id perhaps can not be found in this branch
        commits = iter_count_commits(
            options.branch,
            options.commit, 1, 1)
    else:
        log.info("No commits choosed, only the head commit will be run.")
        commits = iter_count_commits(
            options.branch,
            REPO.heads[options.branch].commit.__str__(), 1, 1)

    # pick the commits selected
    clean_workspace()
    results = OrderedDict()

    begin_run = time()
    for commit in commits:
        # compile
        compile_time = compile_bench_for_commit(options.bench, commit, options.repo_path)
        log.info("**compiled time: " + str(compile_time))

        t = timeit.Timer(
            stmt="\n".join(options.statement), setup=options.setup)
        records = t.repeat(repeat=options.repeat, number=options.n)
        best_time = min(records)
        log.info("**{} loops, best of {}: {} usec per loop".format(
            options.n, options.repeat, best_time))

        # log the results
        tmp_result = OrderedDict({
            "compile_time": compile_time,
            "best_time": best_time})
        results[commit] = tmp_result

        clean_workspace()
    end_run = time()

    log.info("plotting results")
    figname = "%s_%s.png" % ("dprod", options.branch)
    plot_results(results, options.branch, show=options.show)

    print "==========================finished in {} secs\
==========================".format(end_run - begin_run)
