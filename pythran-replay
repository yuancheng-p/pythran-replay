#!/usr/bin/env python
import argparse
import imp
import os
from time import time
import git
try:
    from collections import OrderedDict
except:
    from ordereddict import OrderedDict

REPO = git.Repo(os.getcwd())


def time_once(statements):
    tic = time()
    for statement in statements:
        exec statement
    toc = time()
    return toc - tic


def run_statements(statements, count=100):
    """run a list of statement 'count' times
    return best timing
    """
    all_timings = []
    for i in xrange(count):
        all_timings.append(time_once(statements))

    best_timing = min(all_timings)

    return best_timing


def iter_count_commits(branch, begin, count, step=1):
    """ Iterate commits with a begin commit

    count is the number of commits retured
    step is the distance between two commits
    """
    commits = REPO.iter_commits(branch, max_count=count * step)
    cnt = 0
    already_begin = False

    for commit in commits:
        if commit.__str__() == begin or already_begin:
            if not already_begin:
                already_begin = True
            if cnt % step == 0:
                yield commit
            cnt += 1


def iter_commits(branch, begin, end, step=1):
    """ Iterate commits with a begin commit and an end commit

    step is the distance between two commits
    """
    commits = REPO.iter_commits(branch)
    cnt = 0
    already_begin = False

    for commit in commits:
        if commit.__str__() == end:
            break

        if commit.__str__() == begin or already_begin:
            if not already_begin:
                already_begin = True
            if cnt % step == 0:
                yield commit
            cnt += 1


def compile_bench_for_commit(bench, commit):
    """comile a bench for a pythran commit

    the bench is the **pythran file path**
    return: compile time
    """
    def compile_once(script):
        tic = time()
        os.system(script)
        toc = time()
        return toc - tic

    REPO.git.checkout(commit)
    print "------current commit: " + REPO.head.commit.__str__()
    script = "./scripts/pythran  " + bench
    return compile_once(script)


def parse_args(args):
    """
    classic senario:
    ./pythran-reply <pythran file> [-s SETUP] [statement]
    """
    parser = argparse.ArgumentParser(
        description="Pythran commits replay tool")
    # positional
    parser.add_argument("bench", type=str, help="Pythran declared python file")
    parser.add_argument("statement", type=str, nargs="+", help="")

    # optional
    # TODO setup can be a python file ?
    parser.add_argument("-s", "--setup", #type=str,
        help="statement to be executed once initially")
    parser.add_argument("-n", type=int, default=10000,
        help="how many times to execute 'statement'")

    parser.add_argument(
        "-b", "--branch", default='serge/master', help="branch name")

    # Other options
    # TODO default begin is HEAD
    parser.add_argument(
        "-r", default=None,
        help="Starting and ending commit_id r0:rN:step.")
    parser.add_argument(
        "--count_range",
        help="Starting commit_id and number of commits r0:N:step.")
    parser.add_argument(
        "-c", help="Run a benchmark for a specific commit")

    return parser.parse_args()


def clean_workspace():
    os.system("rm -f *.so")


def bench_analyse(folder):
    """analyse a relative path

    return: benchmark functions object
            make_env
    """
    pass

def plot_results(results):
    pass

if __name__ == "__main__":
    import sys
    import re
    options = parse_args(sys.argv[1:])

    """ in the options:
    *bench:      pythran file path
    *statement:  statement to be executed once initially
     setup:      statement to be executed once initially
     n:          how many times to execute 'statement'
    """

    begin = "9887815c92b64b36ebb4d229e1c3a6e52cb80329"

    # pick the commits selected
    commits = iter_count_commits(options.branch, begin, 20, 2)

    clean_workspace()
    begin_run = time()
    for commit in commits:
        # compile
        c_time = compile_bench_for_commit(options.bench, commit)
        print "-----compiled time: " + str(c_time)

        # setup environment
        if options.setup:
            exec options.setup

        # run statements
        print run_statements(options.statement, options.n)
        clean_workspace()
    end_run = time()

    print "==========================finished in {} secs\
==========================".format(end_run - begin_run)
