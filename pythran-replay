#!/usr/bin/env python
"""
./pythran-replay ./benchmark/dprod/dprod.py
    -s 'from dprod import dprod;l0=[1]*100000;l1=[2]*100000'
    'dprod(l0,l1)' --url ../pythran -b master -n 100
    --count_rng cc9294c07bfcc46540223700a1bb951219dccabc:20:2
"""
import argparse
import imp
import os
from time import time, strftime, localtime
import timeit
import git
try:
    from collections import OrderedDict
except:
    from ordereddict import OrderedDict
import logging
import matplotlib.pyplot as plt
import commands
import sys


# log settings
log = logging.getLogger(__name__)
log.setLevel(logging.DEBUG)
ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)
formatter = logging.Formatter(
    '%(asctime)s\t%(levelname)s:  %(message)s', '%m/%d/%Y %H:%M:%S')
ch.setFormatter(formatter)
log.addHandler(ch)


def verify_commit(branch, commit):
    commits = REPO.iter_commits(branch)
    for current in commits:
        if current.__str__() == commit:
            return True
    log.error(
        "commit \"%s\" is not in the branch \"%s\"" %
        (commit, branch))
    sys.exit()


def iter_count_commits(branch, begin, count=1, step=1):
    """ Iterate commits with a begin commit

    count is the number of commits returned
    step is the distance between two commits
    """
    verify_commit(branch, begin)

    commits = REPO.iter_commits(branch)
    cnt = 0
    already_begin = False

    for commit in commits:
        if cnt == count:
            break

        if commit.__str__() == begin or already_begin:
            if not already_begin:
                already_begin = True
            if cnt % step == 0:
                yield commit
            cnt += 1


def iter_commits(branch, begin, end, step=1):
    """ Iterate commits with a begin commit and an end commit

    step is the distance between two commits
    """
    verify_commit(branch, begin)
    verify_commit(branch, end)

    commits = REPO.iter_commits(branch)
    cnt = 0
    already_begin = False

    for commit in commits:
        if commit.__str__() == end:
            break

        if commit.__str__() == begin or already_begin:
            if not already_begin:
                already_begin = True
            if cnt % step == 0:
                yield commit
            cnt += 1


def compile_bench_for_commit(bench, commit, url=".", quiet=False):
    """comile a bench for a pythran commit

    the bench is the **pythran file path**
    return: * compile time
            * -1 if compile failed
    """
    def compile_once(script):
        tic = time()
        fail = commands.getstatusoutput(script)
        toc = time()
        if fail != (0, ''):
            raise Exception(fail[1])
        return toc - tic

    REPO.git.checkout(commit)
    log.info("current commit: " + REPO.head.commit.__str__())
    script = "python %s/scripts/pythran %s" % (url, bench)
    try:
        compile_time = compile_once(script)
    except Exception as e:
        error_type = type(e).__name__
        error_msg = str(e)
        log.error("**Failed to compile %s", bench)
        # TODO it could be a pythran's compile warning
        if not quiet:
            log.error("\n%s" % error_msg)
        return -1
    return compile_time


def clean_workspace():
    os.system("rm -f *.so")


def build_reports(results, filename="report"):
    """
    need each commit message
    """
    filepath = "%s.log" % (filename)
    fnum = 0
    while os.path.exists(filepath):
        fnum += 1
        filepath = "%s_(%d).log" % (filename, fnum)
    log.info("Building reports \"%s\"" % filepath)

    f = file(filepath, "w")

    count = 1
    for commit, result in results.items():
        f.write(
            """
[commit %d] %s
    Compile time: %s
    Best time: %s
    Author: %s
    Authored date: %s
    message: %s

            """ % (
            count, commit.hexsha,
            result['compile_time'],
            result['best_time'],
            commit.author.name.encode("utf8"),
            strftime("%X, %x, %Z", localtime(commit.authored_date)),
            commit.message.encode("utf8")))
        count += 1

    f.close()


def plot_results(results, figname, show=True, scale=None):
    """
    results is an OrderedDict
    x: commit_date
    y: best_time
    """

    commits_time = []
    execute_times = []
    xcnts = []
    cnt = 0

    for commit, result in results.items():
        cnt += 1
        xcnts.append(cnt)
        execute_times.append(result['best_time'])

    plt.xlabel("Commit")
    reversed_xcnts = range(len(xcnts) + 1)[1:]
    reversed_xcnts.reverse()
    plt.xticks(xcnts, reversed_xcnts)
    plt.ylabel("Best execute time")
    plt.title("Commits Performance History")

    # TODO users may choose the scale of Y axis
    plt.plot(xcnts, execute_times, '--r*', label="$master$")

    if scale:
        plt.ylim(scale)
    else:
        up = max(execute_times) + 0.1
        down = min(execute_times) - 0.1
        plt.ylim([down, up])

    plt.xlim([0, xcnts[-1] + 1])

    filepath = "%s.png" % (figname)
    fnum = 0
    while os.path.exists(filepath):
        fnum += 1
        filepath = "%s_%d.png" % (figname, fnum)

    log.info("saving results image \"%s\"" % filepath)
    # TODO to find a propre dpi
    plt.savefig(filepath, dpi=150)

    if show:
        plt.show()


def parse_args(args):
    """
    """
    parser = argparse.ArgumentParser(
        description="Pythran Commits Replay Tool")
    # positional
    parser.add_argument("bench", type=str, help="Pythran declared python file")
    parser.add_argument("statement", type=str, nargs="+", help="")

    try:
        import argcomplete
        argcomplete.autocomplete(parser)
    except:
        log.warn("argcomplete not found")

    # optional
    # TODO setup can be a python file ?
    parser.add_argument(
        "-s", "--setup", default="pass",
        help="statement to be executed once initially, by defaut pass")
    parser.add_argument(
        "-n", type=int, default=100,
        help="how many times to execute 'statement', by default 100")
    parser.add_argument(
        "-r", "--repeat", type=int, default=3,
        help="how many times repeat the experiment, by default 3")
    parser.add_argument(
        "--url", type=str, default=".",
        help="pythran repository path")
    parser.add_argument(
        "-b", "--branch", default='master',
        help="git branch, by default master")
    parser.add_argument(
        "--show", action="store_true",
        help="show plot results after execution")
    parser.add_argument(
        "-q", "--quiet", action="store_true",
        help="do not show pythran compile error or warning message")

    # commits selection
    group = parser.add_mutually_exclusive_group()
    group.add_argument(
        "--range", default=None,
        help="r0[:rn[:step]]")
    group.add_argument(
        "--count_range", default=None,
        help="starting commit_id and number of commits r_0:n:step.")

    return parser.parse_args()


def get_commits(options):
    if options.range:
        regex = "^[0-9a-zA-Z]{40,40}(:[0-9a-zA-Z]{40,40})?(:[0-9]{1,3})?$"
        if not re.match(regex, options.range):
            log.error("--range is not valid!")
            sys.exit()
        selects = options.range.split(":")
        if len(selects) == 1:
            commits = iter_count_commits(
                options.branch,
                selects[0], 1, 1)
        elif len(selects) == 2:
            commits = iter_commits(
                options.branch,
                selects[0], selects[1], 1)
        elif len(selects) == 3:
            commits = iter_commits(
                options.branch,
                selects[0], selects[1], selects[2])
    elif options.count_range:
        regex = "^[0-9a-zA-Z]{40,40}(:[0-9]{1,4})?(:[0-9]{1,3})?$"
        if not re.match(regex, options.count_range):
            log.error("--count_range is not valid!")
            sys.exit()
        cnt_rng = options.count_range.split(":")
        commits = iter_count_commits(
            options.branch, cnt_rng[0],
            int(cnt_rng[1]), int(cnt_rng[2]))
    else:
        log.info("No commits choosed, only the head commit will be run.")
        commits = iter_count_commits(
            options.branch, REPO.heads[options.branch].commit.__str__(), 1, 1)

    return commits


if __name__ == "__main__":
    import re

    options = parse_args(sys.argv[1:])
    global REPO

    """ in the options:
    *bench:      pythran file path
    *statement:  statement to time
     setup:      statement to be executed once initially
     n:          how many times to execute 'statement'
     repeat:     number of experiments
     range:      r0[:r1[:step]]
     count_range:Starting commit_id and number of commits r0:N:step.
     show:       show plot figure after execution
     url:        pythran repository path
     quiet:      do not print pythran error msg
    """

    REPO = git.Repo(options.url)

    if not os.path.exists(options.bench):
        log.error("file \"%s\" doesn't exist" % options.bench)
        sys.exit()

    # pick the selected commits
    commits = get_commits(options)

    clean_workspace()
    results = OrderedDict()

    begin_run = time()
    debug_count = 1
    for commit in commits:
        # compile
        log.info("[commit %d]" % debug_count)
        debug_count += 1
        compile_time = compile_bench_for_commit(
            options.bench, commit, options.url, quiet=options.quiet)

        if compile_time == -1:
            continue

        log.info("**compiled time: %.3f" % compile_time)

        try:
            t = timeit.Timer(
                stmt="\n".join(options.statement), setup=options.setup)
            records = t.repeat(repeat=options.repeat, number=options.n)
            best_time = min(records)
            log.info("**{} loops, best of {}: {} seconds per loop".format(
                options.n, options.repeat, best_time))
            # log the results
            tmp_result = OrderedDict({
                "compile_time": compile_time,
                "best_time": best_time})
            results[commit] = tmp_result
        except Exception:
            log.warn(
                "\nOccurred an error in the timeit module which " +
                "might continue happening in the following commits! " +
                "<Ctrl + C> to stop running")
            t.print_exc()

        clean_workspace()
    end_run = time()

    log.info("plotting results")
    basename = os.path.basename(options.bench)
    filename = "%s_%s" % (basename[:-3], options.branch)
    filename = re.sub(r"/", "_", filename)
    build_reports(results, filename)
    # TODO also plot the compile time
    # TODO add scale option
    plot_results(results, filename, show=options.show)

    print "================================ \
finished in %.3f secs ================================" % (end_run - begin_run)
