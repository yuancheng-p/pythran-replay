#!/usr/bin/env python
"""
./pythran-replay ./benchmark/dprod/dprod.py -s 'from dprod import dprod;l0=[1]*100000;l1=[2]*100000' 'dprod(l0,l1)' -b master --count_rng cc9294c07bfcc46540223700a1bb951219dccabc:20:2  -n 100
"""
import argparse
import imp
import os
from time import time, strftime, gmtime
import git
try:
    from collections import OrderedDict
except:
    from ordereddict import OrderedDict
import logging
import matplotlib.pyplot as plt

REPO = git.Repo(os.getcwd())

# log settings
log = logging.getLogger(__name__)
log.setLevel(logging.DEBUG)
ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)
formatter = logging.Formatter(
    '%(asctime)s\t%(levelname)s:  %(message)s', '%m/%d/%Y %H:%M:%S')
ch.setFormatter(formatter)
log.addHandler(ch)



def time_once(statements):
    tic = time()
    for statement in statements:
        exec statement
    toc = time()
    return toc - tic


def run_statements(statements, count=10):
    """run a list of statement 'count' times
    return best timing
    """
    all_timings = []
    for i in xrange(count):
        all_timings.append(time_once(statements))

    best_timing = min(all_timings)

    return best_timing


def iter_count_commits(branch, begin, count, step=1):
    """ Iterate commits with a begin commit

    count is the number of commits retured
    step is the distance between two commits
    """
    commits = REPO.iter_commits(branch)
    cnt = 0
    already_begin = False

    for commit in commits:
        if cnt == count:
            break

        if commit.__str__() == begin or already_begin:
            if not already_begin:
                already_begin = True
            if cnt % step == 0:
                yield commit
            cnt += 1


def iter_commits(branch, begin, end, step=1):
    """ Iterate commits with a begin commit and an end commit

    step is the distance between two commits
    """
    commits = REPO.iter_commits(branch)
    cnt = 0
    already_begin = False

    for commit in commits:
        if commit.__str__() == end:
            break

        if commit.__str__() == begin or already_begin:
            if not already_begin:
                already_begin = True
            if cnt % step == 0:
                yield commit
            cnt += 1


def compile_bench_for_commit(bench, commit):
    """comile a bench for a pythran commit

    the bench is the **pythran file path**
    return: compile time
    """
    def compile_once(script):
        tic = time()
        os.system(script)
        toc = time()
        return toc - tic

    REPO.git.checkout(commit)
    log.info("current commit: " + REPO.head.commit.__str__())
    script = "python ./scripts/pythran  " + bench
    return compile_once(script)


def parse_args(args):
    """
    classic senario:
    ./pythran-reply <pythran file> [-s SETUP] [statement]
    """
    parser = argparse.ArgumentParser(
        description="Pythran Commits Replay Tool")
    # positional
    parser.add_argument("bench", type=str, help="Pythran declared python file")
    parser.add_argument("statement", type=str, nargs="+", help="")

    # optional
    # TODO setup can be a python file ?
    parser.add_argument("-s", "--setup",
        help="statement to be executed once initially")
    parser.add_argument("-n", type=int, default=10000,
        help="how many times to execute 'statement'")
    parser.add_argument("-r", "--repeat", type=int, default=3)


    parser.add_argument(
        "-b", "--branch", default='master', help="git branch, by default master")

    # group options
    group = parser.add_mutually_exclusive_group()
    group.add_argument(
        "--rng", default=None,
        help="starting and ending commit_id r_0:r_n:step.")
    group.add_argument(
        "--count_rng",
        help="starting commit_id and number of commits r_0:n:step.")
    group.add_argument(
        "-c", "--commit", help="run for a specific commit")

    return parser.parse_args()


def clean_workspace():
    os.system("rm -f *.so")


def plot_results(results, figname):
    """
    results is an OrderedDict
    x: commit_time
    y: best_time
    """
    def normalize(l):
        max_value = max(l)
        min_value = min(l)
        scale = max_value - min_value
        for i in xrange(len(l)):
            l[i] = (l[i] - min_value) / scale
        return l

    commits_time = []
    xcnts = []
    perfs = []
    cnt = 0
    for commit, result in results.items():
        cnt += 1
        xcnts.append(cnt)
        timestr = strftime("%X, %x",
                gmtime(commit.committed_date))
        commits_time.append(timestr)
        perfs.append(result['best_time'])

    commits_time.reverse()
    perfs.reverse()
    #perfs = normalize(perfs)

    plt.xlabel("commits_time")
    plt.xticks(xcnts, commits_time, rotation=15)
    plt.ylabel("perfs")
    plt.title("commits performance history")
    plt.legend()
    plt.plot(xcnts, perfs, '--r*', label="$master$")

    filepath = "%s.png" % (figname)
    plt.savefig(filepath)

    plt.show()


if __name__ == "__main__":
    import sys
    import re
    options = parse_args(sys.argv[1:])

    """ in the options:
    *bench:      pythran file path
    *statement:  statement to time
     setup:      statement to be executed once initially
     n:          how many times to execute 'statement'
     repeat:     number of experiments
     rng:        Starting and ending commit_id r0:rN:step.
     count_rng:  Starting commit_id and number of commits r0:N:step.
     commit:     Run a benchmark for a specific commit
    """

    if options.count_rng:
        cnt_range = options.count_rng.split(":")
        # TODO commit id perhaps can not be found in this branch
        commits = iter_count_commits(
            options.branch, 
            cnt_range[0], int(cnt_range[1]), int(cnt_range[2]))
    elif options.rng:
        rng = options.rng.split(":")
        # TODO commit id perhaps can not be found in this branch
        commits = iter_commits(
            options.branch,
            rng[0], rng[1], int(rng[2]))
    elif options.commit:
        # TODO commit id perhaps can not be found in this branch
        commits = iter_count_commits(
            options.branch, 
            options.commit, 1, 1)
    else:
        log.info("No commits choosed, only the head commit will be run.")
        commits = iter_count_commits(
            options.branch, 
            REPO.heads[options.branch].commit.__str__(), 1, 1)

    # pick the commits selected
    clean_workspace()
    results = OrderedDict()
    begin_run = time()
    for commit in commits:
        # compile
        compile_time = compile_bench_for_commit(options.bench, commit)
        log.info("**compiled time: " + str(compile_time))
        # setup environment
        if options.setup:
            exec options.setup
        # run statements
        records = []
        ######### perhaps use timeit ##########
        for i in xrange(options.repeat):
            records.append(run_statements(options.statement, options.n))
        best_time = min(records)
        log.info(
                "**{} loops, best of {}: {} sec per loop".format(
                    options.n, options.repeat, best_time 
                    ))
        #######################################

        ##### log the results
        tmp_result = OrderedDict({
                "compile_time" : compile_time,
                "best_time" : best_time})
        results[commit] = tmp_result
        ####
        clean_workspace()
    
    log.info("plotting results")
    figname = "%s_%s.png" % ("dprod", options.branch)
    plot_results(results, options.branch)
    end_run = time()

    print "==========================finished in {} secs\
==========================".format(end_run - begin_run)
