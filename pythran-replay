#!/usr/bin/env python
"""
example:
    ./pythran-replay ./benchmark/dprod/dprod.py -s 'from dprod import dprod;l0=[1]*1000;l1=[2]*1000' 'dprod(l0,l1)' --count_rng 9887815c92b64b36ebb4d229e1c3a6e52cb80329:3:2
"""
import argparse
import imp
import os
from time import time
import git
try:
    from collections import OrderedDict
except:
    from ordereddict import OrderedDict

REPO = git.Repo(os.getcwd())


def time_once(statements):
    tic = time()
    for statement in statements:
        exec statement
    toc = time()
    return toc - tic


def run_statements(statements, count=10):
    """run a list of statement 'count' times
    return best timing
    """
    all_timings = []
    for i in xrange(count):
        all_timings.append(time_once(statements))

    best_timing = min(all_timings)

    return best_timing


def iter_count_commits(branch, begin, count, step=1):
    """ Iterate commits with a begin commit

    count is the number of commits retured
    step is the distance between two commits
    """
    commits = REPO.iter_commits(branch)
    cnt = 0
    already_begin = False

    for commit in commits:
        if cnt == count:
            break

        if commit.__str__() == begin or already_begin:
            if not already_begin:
                already_begin = True
            if cnt % step == 0:
                yield commit
            cnt += 1


def iter_commits(branch, begin, end, step=1):
    """ Iterate commits with a begin commit and an end commit

    step is the distance between two commits
    """
    commits = REPO.iter_commits(branch)
    cnt = 0
    already_begin = False

    for commit in commits:
        if commit.__str__() == end:
            break

        if commit.__str__() == begin or already_begin:
            if not already_begin:
                already_begin = True
            if cnt % step == 0:
                yield commit
            cnt += 1


def compile_bench_for_commit(bench, commit):
    """comile a bench for a pythran commit

    the bench is the **pythran file path**
    return: compile time
    """
    def compile_once(script):
        tic = time()
        os.system(script)
        toc = time()
        return toc - tic

    REPO.git.checkout(commit)
    print "------current commit: " + REPO.head.commit.__str__()
    script = "./scripts/pythran  " + bench
    return compile_once(script)


def parse_args(args):
    """
    classic senario:
    ./pythran-reply <pythran file> [-s SETUP] [statement]
    """
    parser = argparse.ArgumentParser(
        description="Pythran commits replay tool")
    # positional
    parser.add_argument("bench", type=str, help="Pythran declared python file")
    parser.add_argument("statement", type=str, nargs="+", help="")

    # optional
    # TODO setup can be a python file ?
    parser.add_argument("-s", "--setup", #type=str,
        help="statement to be executed once initially")
    parser.add_argument("-n", type=int, default=10000,
        help="how many times to execute 'statement'")

    parser.add_argument(
        "-b", "--branch", default='serge/master', help="branch name")

    # Other options
    # TODO default begin is HEAD
    parser.add_argument(
        "-r", "--rng", default=None,
        help="Starting and ending commit_id r0:rN:step.")
    parser.add_argument(
        "--count_rng",
        help="Starting commit_id and number of commits r0:N:step.")
    parser.add_argument(
        "-c", "--commit", help="Run a benchmark for a specific commit")

    return parser.parse_args()


def clean_workspace():
    os.system("rm -f *.so")


def bench_analyse(folder):
    """analyse a relative path

    return: benchmark functions object
            make_env
    """
    pass


def plot_results(results):
    pass


if __name__ == "__main__":
    import sys
    import re
    options = parse_args(sys.argv[1:])

    """ in the options:
    *bench:      pythran file path
    *statement:  statement to be executed once initially
     setup:      statement to be executed once initially
     n:          how many times to execute 'statement'
     rng:        Starting and ending commit_id r0:rN:step.
     count_rng:  Starting commit_id and number of commits r0:N:step.
     commit:     Run a benchmark for a specific commit
    """

    if options.count_rng:
        cnt_range = options.count_rng.split(":")
        # TODO commit id perhaps can not be found in this branch
        commits = iter_count_commits(
            options.branch, 
            cnt_range[0], int(cnt_range[1]), int(cnt_range[2]))
    elif options.rng:
        rng = options.rng.split(":")
        # TODO commit id perhaps can not be found in this branch
        commits = iter_commits(
            options.branch,
            rng[0], rng[1], int(rng[2]))
    elif options.commit:
        # TODO commit id perhaps can not be found in this branch
        commits = iter_count_commits(
            options.branch, 
            options.commit, 1, 1)
    else:
        print "No commits choosed, only the head commit will be run."
        commits = iter_count_commits(
            options.branch, 
            REPO.heads[options.branch].commit.__str__(), 1, 1)

    # pick the commits selected
    clean_workspace()
    results = {}
    begin_run = time()
    for commit in commits:
        # compile
        compile_time = compile_bench_for_commit(options.bench, commit)
        print "----------compiled time: " + str(compile_time)
        # setup environment
        if options.setup:
            exec options.setup
        # run statements
        best_time = run_statements(options.statement, options.n)
        print best_time

        ##### log the results
        tmp_result = {
                "compile_time" : compile_time,
                "best_time" : best_time}
        results[commit] = tmp_result
        ####
        clean_workspace()

    end_run = time()

    print "==========================finished in {} secs\
==========================".format(end_run - begin_run)
