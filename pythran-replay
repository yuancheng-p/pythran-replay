#!/usr/bin/env python
"""
./pythran-replay ./benchmark/dprod/dprod.py
    -s 'from dprod import dprod;l0=[1]*100000;l1=[2]*100000'
    'dprod(l0,l1)' --url ../pythran -b master -n 100
    --count_rng cc9294c07bfcc46540223700a1bb951219dccabc:20:2
"""
import argparse
import imp
import os
from time import time, strftime, localtime
import timeit
import git
try:
    from collections import OrderedDict
except:
    from ordereddict import OrderedDict
import logging
import matplotlib.pyplot as plt
import commands
import sys


# log settings
log = logging.getLogger(__name__)
log.setLevel(logging.DEBUG)
ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)
formatter = logging.Formatter(
    '%(asctime)s\t%(levelname)s:  %(message)s', '%m/%d/%Y %H:%M:%S')
ch.setFormatter(formatter)
log.addHandler(ch)


def verify_commit(branch, commit):
    commits = REPO.iter_commits(branch)
    for current in commits:
        if current.__str__() == commit:
            return True
    log.error(
        "commit \"%s\" is not in the branch \"%s\"" %
        (commit, branch))
    sys.exit()


def iter_count_commits(branch, begin, count=1, step=1):
    """ Iterate commits with a begin commit

    count is the number of commits returned
    step is the distance between two commits
    """
    verify_commit(branch, begin)

    commits = REPO.iter_commits(branch)
    cnt = 0
    already_begin = False

    for commit in commits:
        if cnt == count:
            break

        if commit.__str__() == begin or already_begin:
            if not already_begin:
                already_begin = True
            if cnt % step == 0:
                yield commit
            cnt += 1


def iter_commits(branch, begin, end, step=1):
    """ Iterate commits with a begin commit and an end commit

    step is the distance between two commits
    """
    verify_commit(branch, begin)
    verify_commit(branch, end)

    commits = REPO.iter_commits(branch)
    cnt = 0
    already_begin = False

    for commit in commits:
        if commit.__str__() == end:
            break

        if commit.__str__() == begin or already_begin:
            if not already_begin:
                already_begin = True
            if cnt % step == 0:
                yield commit
            cnt += 1


def compile_bench_for_commit(bench, commit, url=".", quiet=False):
    """comile a bench for a pythran commit

    the bench is the **pythran file path**
    return: * compile time
            * -1 if compile failed
    """
    def compile_once(script):
        tic = time()
        fail = commands.getstatusoutput(script)
        toc = time()
        if fail != (0, ''):
            raise Exception(fail[1])
        return toc - tic

    REPO.git.checkout(commit)
    script = "python %s/scripts/pythran %s" % (url, bench)
    try:
        compile_time = compile_once(script)
    except Exception as e:
        error_type = type(e).__name__
        error_msg = str(e)
        log.error("**Failed to compile %s", bench)
        # TODO it could be a pythran's compile warning
        if not quiet:
            log.error("\n%s" % error_msg)
        return -1
    return compile_time


def clean_workspace():
    os.system("rm -f *.so")


def build_reports(options, results, total_time, filename="report"):
    """
    need each commit message
    """
    filepath = "%s.log" % (filename)
    fnum = 0
    while os.path.exists(filepath):
        fnum += 1
        filepath = "%s_%d.log" % (filename, fnum)
    log.info("Building reports \"%s\"" % filepath)

    f = file(filepath, "w")

    # get step, get begin commit
    if options.count_range:
        selects = options.count_range.split(":")
        step = selects[2]
        begin_commit = selects[0]
    else:
        selects = options.range.split(":")
        begin_commit = selects[0]
        if len(selects) == 3:
            step = selects[2]
        else:
            step = 1

    # write basic info:
    f.write(
        """##
#
# Date: %s
#
# [REPO INFORMATION]
#     url: %s
#     branch: %s
#
# [BENCHMARK]
#     benchmark: %s
#     setup: %s
#     statement: %s
#
# [COMMITS SELECTED]
#     start commit: %s
#     step: %s
#
# [RESULTS]
#     total : %d
#     passed: %d
#     finished in: %.2f seconds
##
""" % (
        strftime("%X, %x, %Z", localtime()),
        options.url, options.branch,
        options.bench, options.setup, ";".join(options.statement),
        begin_commit, step,
        sum(1 for commit in get_commits(options)),
        len(results), total_time))

    # write results
    count = 1
    for commit, result in results.items():
        f.write(
            """

[commit %d] %s
    Compile time: %s
    Best time: %s
    Author: %s
    Authored date: %s
    message: %s

""" % (
            count, commit.hexsha,
            result['compile_time'],
            result['best_time'],
            commit.author.name.encode("utf8"),
            strftime("%X, %x, %Z", localtime(commit.authored_date)),
            commit.message.encode("utf8")))
        count += 1

    f.close()


def plot_results(results, figname, show=True, scale=None):
    """
    results is an OrderedDict
    x: commit_date
    y: best_time
    y2: compile_time
    """

    compile_times = []
    execute_times = []
    xcnts = []
    cnt = 0

    for commit, result in results.items():
        cnt += 1
        xcnts.append(cnt)
        execute_times.append(result['best_time'])
        compile_times.append(result['compile_time'])

    # TODO users may choose the scale of Y axis
    plt.title("Commits Performance History")
    #compile_ax configure
    plt.subplot(211)
    # TODO How to present only integer on x axis?
    plt.plot(xcnts, compile_times, '--r*')
    plt.ylabel("Compile time")
    plt.grid(True)
    up = max(compile_times) + 2
    down = min(compile_times) - 2
    plt.ylim([down, up])
    plt.xlim([0, xcnts[-1] + 1])

    # TODO How to share the same axis?
    #execute_ax configure
    plt.subplot(212)
    plt.plot(xcnts, execute_times, '--b*')
    plt.ylabel("Best execute time")
    plt.xlabel("Commit")
    plt.grid(True)
    up = max(execute_times) + 0.05
    down = min(execute_times) - 0.05
    plt.ylim([down, up])
    plt.xlim([0, xcnts[-1] + 1])

    filepath = "%s.png" % (figname)
    fnum = 0
    while os.path.exists(filepath):
        fnum += 1
        filepath = "%s_%d.png" % (figname, fnum)

    log.info("Saving results image \"%s\"" % filepath)
    # TODO to find a propre dpi
    plt.savefig(filepath, dpi=150)

    if show:
        plt.show()


def parse_args(args):
    """
    """
    parser = argparse.ArgumentParser(
        description="Pythran Commits Replay Tool")
    # positional
    parser.add_argument("bench", type=str, help="Pythran declared python file")
    parser.add_argument("statement", type=str, nargs="+", help="")

    try:
        import argcomplete
        argcomplete.autocomplete(parser)
    except:
        log.warn("argcomplete not found")

    # optional
    # TODO setup can be a python file ?
    parser.add_argument(
        "-s", "--setup", default="pass",
        help="statement to be executed once initially, by defaut pass")
    parser.add_argument(
        "-n", type=int, default=100,
        help="how many times to execute 'statement', by default 100")
    parser.add_argument(
        "-r", "--repeat", type=int, default=3,
        help="how many times repeat the experiment, by default 3")
    parser.add_argument(
        "--url", type=str, default=".",
        help="pythran repository path")
    parser.add_argument(
        "-b", "--branch", default='master',
        help="git branch, by default master")
    parser.add_argument(
        "--show", action="store_true",
        help="show plot results after execution")
    parser.add_argument(
        "-q", "--quiet", action="store_true",
        help="do not show pythran compile error or warning message")

    # commits selection
    group = parser.add_mutually_exclusive_group()
    group.add_argument(
        "--range", default=None,
        help="r0[:rn[:step]]")
    group.add_argument(
        "--count_range", default=None,
        help="starting commit_id and number of commits r_0:n:step.")

    return parser.parse_args()


def get_commits(options):
    if options.range:
        regex = "^[0-9a-zA-Z]{40,40}(:[0-9a-zA-Z]{40,40})?(:[0-9]{1,3})?$"
        if not re.match(regex, options.range):
            log.error("--range is not valid!")
            sys.exit()
        selects = options.range.split(":")
        if len(selects) == 1:
            commits = iter_count_commits(
                options.branch,
                selects[0], 1, 1)
        elif len(selects) == 2:
            commits = iter_commits(
                options.branch,
                selects[0], selects[1], 1)
        elif len(selects) == 3:
            commits = iter_commits(
                options.branch,
                selects[0], selects[1], selects[2])
    elif options.count_range:
        regex = "^[0-9a-zA-Z]{40,40}(:[0-9]{1,4})?(:[0-9]{1,3})?$"
        if not re.match(regex, options.count_range):
            log.error("--count_range is not valid!")
            sys.exit()
        cnt_rng = options.count_range.split(":")
        commits = iter_count_commits(
            options.branch, cnt_rng[0],
            int(cnt_rng[1]), int(cnt_rng[2]))
    else:
        log.info("No commits choosed, only the head commit will be run.")
        commits = iter_count_commits(
            options.branch, REPO.heads[options.branch].commit.__str__(), 1, 1)

    return commits


if __name__ == "__main__":
    import re

    options = parse_args(sys.argv[1:])
    global REPO

    """ in the options:
    *bench:      pythran file path
    *statement:  statement to time
     setup:      statement to be executed once initially
     n:          how many times to execute 'statement'
     repeat:     number of experiments
     range:      r0[:r1[:step]]
     count_range:Starting commit_id and number of commits r0:N:step.
     show:       show plot figure after execution
     url:        pythran repository path
     quiet:      do not print pythran error msg
    """

    REPO = git.Repo(options.url)

    if not os.path.exists(options.bench):
        log.error("file \"%s\" doesn't exist" % options.bench)
        sys.exit()

    commits = get_commits(options)
    num_commits = sum(1 for commit in commits)
    # pick the selected commits
    commits = get_commits(options)
    results = OrderedDict()
    commit_count = 1

    clean_workspace()
    begin_run = time()
    for commit in commits:
        # compile
        log.info(
            "[commit %d / %d] %s" %
            (commit_count, num_commits, commit.__str__()))
        commit_count += 1
        compile_time = compile_bench_for_commit(
            options.bench, commit, options.url, quiet=options.quiet)

        if compile_time == -1:
            continue

        log.info("**compiled time: %.3f seconds" % compile_time)

        try:
            t = timeit.Timer(
                stmt="\n".join(options.statement), setup=options.setup)
            records = t.repeat(repeat=options.repeat, number=options.n)
            best_time = min(records)
            log.info("**%d loops, best of %d: %.4f seconds per loop" %
                    (options.n, options.repeat, best_time))
            # log the results
            tmp_result = OrderedDict({
                "compile_time": compile_time,
                "best_time": best_time})
            results[commit] = tmp_result
        except Exception:
            log.warn(
                "\nOccurred an error in the timeit module which " +
                "might continue happening in the following commits! " +
                "<Ctrl + C> to stop running")
            t.print_exc()

        clean_workspace()
    end_run = time()
    total_time = end_run - begin_run

    log.info("Plotting results")
    basename = os.path.basename(options.bench)
    filename = "%s_%s" % (basename[:-3], options.branch)
    filename = re.sub(r"/", "_", filename)
    build_reports(options, results, total_time, filename)
    # TODO add scale option
    plot_results(results, filename, show=options.show)
    log.info("finished in %3f seconds" % total_time)
